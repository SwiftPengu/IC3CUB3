\documentclass[a4paper]{article}

\usepackage{hyperref}
\usepackage{parskip}

\begin{document}
\title{Solving RERS 2014 problems with IC3}
\author{H.N. Hindriks\\h.n.hindriks@student.utwente.nl}
\date{\today}
\maketitle

\section{Introduction}
This report covers the individual project performed by H.N. Hindriks, under supervision of T. van Dijk and J.C. Van der Pol, which took place during the 3rd quartile of 2014-2015.

IC3 is a rather new algorithm for model checking, developed by Fabio Somenzi and Aaron Bradley \cite{Bradley2007}. The algorithm relies on providing a SAT-solver (relatively) small queries in order to construct either an inductive proof or a counterexample to induction. The algorithm is described in more detail by Bradley \cite{Bradley2011}.

The RERS challenge (which stand for Rigorous Examination of Reactive Systems), is an internation contest which are currently held annualy. During the contest participants attempt to find bugs in reactive systems of varying complexity using testing and model checking tools.

The aim of the project was to acquire a better in-depth knowledge of the IC3 algorithm, while also experiencing the challenges encountered when model checking real-world-like programs.

\section{Background}
\subsection{SAT}
The IC3 algorithm uses a SAT solver to learn more about the system under verification. Before introducing the IC3 algorithm, it makes sense to briefly explain some basic principles on SAT solving.

Given a propositional logic formula with an arbitrary number of literals, a SAT solver attempts to find a set of truth assignments for each literal which satisfy the formula. This means that substituting the literals with their respective truth assignments results in a formula which evaluates to $\top$. This problem is known as the \emph{Satisfiability} problem. A formula for which such a truth assignment exists is called satisfiable.

\subsection{CNF}
\subsection{Tseitin transformation}
When converting an arbitrary formula to CNF using standard logic equivalence rules, it is possible to create formulae which are exponential in size when compared to the original formula.

Using the Tseitin transformation, it is possible to convert an arbitrary formula to a formula in CNF which is not equal, but equisatisfiable to the original. This means that the new formula is satisfiable iff the original formula is satisfiable. The resulting formula is linear in size when compared to the original formula.

Furthermore, the Tseitin transformed formula also has a 1-to-1 correspondence with satisfiable assignments to the original formula. This means that a satisfiable assignment of the converted formula is easily transformed to a satisfiable assignment of the original formula.

The Tseitin transform introduces new literals for each operator. Each operator is viewed as a logic gate, which consists of some inputs, and a single output. For each operator, a literal is introduced which represents the output of a gate modelling that operator.

%TODO beschrijf AND en OR conversion

\subsection{IC3}
IC3, which stands for 'Incremental Construction of Inductive Clauses for Indubitable Correctness', is a Model Checking algorithm which is able to construct inductive proofs and counterexamples for reachability problems.

%Brief description of IC3

\section{Implementation}
\subsection{Propositional Logic Formulae and CNF}
Two systems for representing propositional logic formulae was developed. A system to represent arbitrary propositional logic formulae, and a system to represent formulae in conjunctive normal form. Furthermore, both systems contain code to convert either system to an equisatisfiable formula in the other system.

The first system supports formulae consisting of the $\lnot$,$\lor$,and $\land$ operators. It is implemented (by an object oriented structure) as a binary tree. It comes with convenience methods which also implement the $\rightarrow$ and $\leftrightarrow$ operators. Negation of the entire formula is also supported.

The second system represents formulae which are in CNF. A single formula is implemented as a cube, a set clauses. A clause is implemented as a set of literals. For example, the formula $(p \land (q \lor \lnot r))$ is represented as $\{\{p\},\{q,\lnot r\}\}$.
\subsubsection{Conversion}
The conversion from the CNF system to the PLF system results in a formula which is equal under $\Leftrightarrow$. However, the conversion from the first to the second system is implemented as the Tseitin transformation, which only preserves equisatisfiability.

\subsection{SAT solver}
%intro
\subsubsection{Logic2CNF}
At the beginning of the project, no formulae representing test cases were avaiable in CNF, and in order to test the semantics of IC3, a SAT solver was needed which supported arbitrary formulae. Logic2CNF is a fork of Minisat, which supports arbitrary formulae. Internally it applies the Tseitin transform algorithm, and drops the newly introduced literals from the output. It is able to find all models for a given formula, but also supports searching up to a specified maximum.

\subsubsection{SAT4J}
SAT4J is a Java implementation of the Minisat SAT solver. It supports only formulae which are in CNF. SAT4J is able to find a single model of a formula, but it is also able to find all models.

Furthermore, it conserves the behaviour of Minisat to report unsatisfiablity whenever a trivially unsatisfiable formula is provided to it (e.g.: $p \land \lnot p$). This enables the SAT solver to return a result early.

\subsection{IC3}
\subsubsection{Overview}
%Beschrijving implementatie main loop en invariants
\subsubsection{The MIC algorithm}
%Down algoritme
\subsubsection{Problem solving architecture}
%Wat informatie over hoe problemen aan het algoritme kunnen worden gevoerd
\subsubsection{Testcases}
%Alle testcases uit 'Where Monolithic and Incremental Meet'
%Hier ook wat zeggen over fout in paper?

\subsection{Encoding} %On the encoding of problems for IC3
\subsubsection{RERS 2014}
%Introduction on RERS 2014
\subsubsection{Problem structure}
%A general overview of structure the problem files
%Tell something about the assumptions made (or in the next section)
\subsubsection{Parser implementation}
%ANTLR4 versie van de grammatica van Jeroen Meijer en Jaco van der Pol.
%ANTLR4 Listener tree walker voor opbouw formules

\subsection{Measurements}
\subsubsection{Description}
%What and how did we measure
\subsubsection{Results}
%Overview of all the checked properties from the first RERS and the results

\subsection{Future Work}
Hassan et al. \cite{Hassan2013} have improved the down algorithm. This improvement supersedes an intermediate improvement by Bradley et al. \cite{Bradley2007} which defines the \emph{up} algorithm. The created Java implementation of the IC3 algorithm only implements part of the \emph{down} algorithm. As the MIC algorithm is essential to the performance of IC3, implementing the improved algorithm could yield better overall performance.

The presented method for representing C programs as propositional logic formulae might very well not be the only existing method to represent such programs. Different encodings might also result in a better performance of either the used SAT-solver, or the generalisation algorithm.

The C programming language can be used to solve a vast array of problems. Restricting the domain for which encodings have to be generated might allow for more general representations of problems due to knowledge on a higher level. For example checking properties on a model of Sokoban is probably more efficient in comparison to a C implementation of the game.

Currently, our IC3 implementation, as well as our SAT-solver, both run on the JVM. The configuration of this JVM directly influences the performance of the program. Not much time was spent optimizing these parameters. For example, it might be worthwhile to investigate the impact of the size of the young generation (used in garbage collection). A different approach might be to implement the algorithm in C (although an implementation is already available at \url{https://github.com/arbrad/IC3ref}).


%JVM optimizen of C code gebruiken
%Toepassingen vinden waarin de generalisatie goed werkt
%Vergelijken met BDDs en CEGAR
%Andere methode voor SAT solven dan DPLL?

\subsection{Conclusion}
We were able to construct a working implementation of the IC3 algorithm in Java, supporting multiple SAT solvers.

\bibliographystyle{plain}
\bibliography{references}

\end{document}
